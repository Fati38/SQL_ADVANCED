

---- 1. Calculate the total revenue generated by each salesperson for the year 2011. Include the salesperson's name and sort the results in descending order of revenue.

--DECLARE    @Sales_year  INT
--SET        @Sales_year =2011


WITH  Total_Sales_Salesperson As (

SELECT      SalesPersonID
            ,s2.FirstName
			,s2.LastName
           ,SUM(TotalDue) as 'Total_Sales_Salesperson'

FROM       [Sales].[SalesOrderHeader] s1
LEFT JOIN  [Person].[Person] s2
ON         s1.SalesPersonID = s2.BusinessEntityID
WHERE      SalesPersonID IS NOT NULL 
AND        YEAR(OrderDate) = 2011
GROUP BY   SalesPersonID

--ORDER BY   Total_Sales_Salesperson desc

)

SELECT   * 
FROM  Total_Sales_Salesperson

--- 2. Find the top 5 most expensive products based on ListPrice, and include their Name, ProductNumber, and ListPrice.

SELECT DISTINCT  TOP 5           
          
		   ProductID
		  ,ListPrice
		  ,Name
		  ,ProductNumber
		 
FROM       [Production].[Product] 
ORDER BY   ListPrice DESC

---  3. Identify the top 3 selling products for the year 2011 based on OrderQty. Include product name, total quantity sold, and total revenue.

--- 1.Using subqueries

SELECT     a.ProductID
           ,b.Name
		   ,a.Total_quantity
		   ,a.Total_revenue

FROM 

(
SELECT  TOP 3    
           s2.ProductID
           ,SUM(s2.OrderQty) AS 'Total_quantity'
		   ,SUM(s1.TotalDue) AS 'Total_revenue'
		   
FROM       [Sales].[SalesOrderHeader] s1
LEFT JOIN  [Sales].[SalesOrderDetail] s2
ON         s1.SalesOrderID = s2.SalesOrderID
WHERE      YEAR(s1.OrderDate) = 2011
GROUP BY   s2.ProductID
ORDER BY   total_quantity DESC


) a

LEFT JOIN  [Production].[Product] b
ON         a.ProductID = b.ProductID

--- 2.Using window functions

SELECT     
           s2.ProductID
           ,SUM(s2.OrderQty) AS 'Total_quantity'
		   ,SUM(s1.TotalDue) AS 'Total_revenue'
		   ,ROW_NUMBER() OVER ( ORDER BY SUM(s2.OrderQty) DESC ) as 'row_number'
		   
		   
FROM       [Sales].[SalesOrderHeader] s1
LEFT JOIN  [Sales].[SalesOrderDetail] s2
ON         s1.SalesOrderID = s2.SalesOrderID
WHERE      YEAR(s1.OrderDate) = 2011
GROUP BY   s2.ProductID

ORDER BY   Total_quantity DESC

---  4. Use a CTE to calculate the average ListPrice of products by ProductCategory. Then, return the categories where the average price exceeds $500.

--- 1.Using Having clause

SELECT      s2.ProductCategoryID
           ,AVG(s1.ListPrice) AS 'avg_ListPrice'

FROM      [Production].[Product]  s1

LEFT JOIN [Production].[ProductSubcategory] s2
ON        s1.ProductSubcategoryID = s2.ProductSubcategoryID
WHERE     s2.ProductCategoryID IS NOT NULL 

GROUP BY s2.ProductCategoryID
HAVING   AVG(s1.ListPrice) > 500
ORDER BY avg_ListPrice


--- 2. USing CTE

WITH    Avg_Listprice AS (

SELECT      s2.ProductCategoryID
           ,AVG(s1.ListPrice) AS 'avg_ListPrice'

FROM      [Production].[Product]  s1

LEFT JOIN [Production].[ProductSubcategory] s2
ON        s1.ProductSubcategoryID = s2.ProductSubcategoryID
WHERE     s2.ProductCategoryID IS NOT NULL 

GROUP BY s2.ProductCategoryID

)
 
SELECT    *
FROM     Avg_Listprice
WHERE    avg_ListPrice > 500

---- 5. Write a query using the ROW_NUMBER() function to rank employees based on their hire date. Include columns BusinessEntityID, FirstName, LastName, and Rank.

SELECT      s1.BusinessEntityID
            ,s2.FirstName
			,s2.LastName
			,s1.HireDate
			,ROW_NUMBER() OVER (
			ORDER BY s1.HireDate ASC ) AS 'Rank'
          
FROM        [HumanResources].[Employee] s1
LEFT JOIN   [Person].[Person] s2
ON          s1.BusinessEntityID = s2.BusinessEntityID

---- 6. Find the average order subtotal for orders placed by each customer in 2011. Include CustomerID, AverageSubtotal, and sort the results by average subtotal in descending order.

SELECT      CustomerID
           ,AVG (SubTotal) AS 'Avg_Subtotal'
		   
FROM        [Sales].[SalesOrderHeader]
WHERE       YEAR(OrderDate) = 2011

GROUP BY    CustomerID
ORDER BY    Avg_Subtotal DESC

--- 10. Identify employees whose total sales in 2011 exceeded the average sales of all employees for the same year. Include the employee's name and total sales.

--- 1.Using Having

SELECT        
               SalesPersonID
			  ,SUM(TotalDue) AS 'Total_sale_SalesPerson'

FROM          [Sales].[SalesOrderHeader] 
WHERE         SalesPersonID IS NOT NULL 
AND           YEAR(OrderDate) = 2011

GROUP BY      SalesPersonID
HAVING        SUM(TotalDue) >   ( SELECT AVG(TotalDue) 
                                  FROM [Sales].[SalesOrderHeader]  
								  WHERE YEAR(OrderDate) = 2011 )

ORDER BY  Total_sale_SalesPerson DESC

--- 2.Using CTE

WITH    avg_per_SalesPerson  AS (

SELECT        
               SalesPersonID
			  ,AVG(TotalDue) AS 'avg_sale_SalesPerson'

FROM          [Sales].[SalesOrderHeader] 
WHERE         SalesPersonID IS NOT NULL 
AND           YEAR(OrderDate) = 2011

GROUP BY      SalesPersonID

)

SELECT         s1.SalesPersonID
              ,SUM(s2.TotalDue) as 'Total_Sales' 
			  ,s1.avg_sale_SalesPerson
			  
FROM          avg_per_SalesPerson s1
LEFT JOIN     [Sales].[SalesOrderHeader]  s2
ON            s1.SalesPersonID = s2.SalesPersonID

GROUP BY       s1.SalesPersonID 
              ,s1.avg_sale_SalesPerson
              
HAVING        SUM(s2.TotalDue) > s1.avg_sale_SalesPerson

ORDER BY     Total_Sales DESC


---- ROWS BETWEEN 
/*

 *********** ROWS BETWEEN *********

<Window_Function>() OVER (
    PARTITION BY <column>
    ORDER BY <column>
    ROWS BETWEEN <starting point> AND <ending point>
)

The ROWS BETWEEN clause specifies the subset of rows, relative to the current row, for a window		function to consider when performing its calculation.
The range is defined using starting point and ending point, which can be one of the following:

UNBOUNDED PRECEDING: Includes all rows from the start of the partition to the current row.
UNBOUNDED FOLLOWING: Includes all rows from the current row to the end of the partition.
CURRENT ROW: Includes only the current row.
n PRECEDING: Includes n rows before the current row.
n FOLLOWING: Includes n rows after the current row.

*/

SELECT      SalesPersonID
           ,OrderDate
		   ,TotalDue
		   ,AVG(TotalDue) OVER ( 
		   PARTITION BY SalesPersonID 
		   ORDER BY OrderDate 
		   ROWS BETWEEN 2 preceding AND current row ) AS 'running_avg'

FROM       [Sales].[SalesOrderHeader]
WHERE      SalesPersonID IS NOT NULL 

ORDER BY    SalesPersonID
           ,OrderDate

--- Cummulitive total sales for months 1 to 8 in 2011

SELECT      
            a.OrderDate
		   ,a.TotalDue
		   ,b.ProductID
		   ,SUM(a.TotalDue) OVER ( PARTITION BY 
		   b.productID 
		   ORDER BY a.OrderDate
		   ROWS BETWEEN unbounded preceding AND current row  ) AS 'cumulitive_total_Due'

FROM       [Sales].[SalesOrderHeader] a
LEFT JOIN  [Sales].[SalesOrderDetail] b
ON         a.SalesOrderID = b.SalesOrderID

WHERE      a.SalesPersonID IS NOT NULL
AND        YEAR(OrderDate) = 2011
AND        Month(OrderDate) BETWEEN 1 AND 8

/*
WITH RECURSIVE cte_name AS (
    -- Anchor Member
    initial_query

    UNION ALL

    -- Recursive Member
    recursive_query_that_references_cte
)
SELECT * FROM cte_name;

*/


